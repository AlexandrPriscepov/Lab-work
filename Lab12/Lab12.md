# 12 Лабораторная Работа
## Прищепов Александр НПМ-03-21
### Введение:
- Цель работы:
    Изучить основы программирования в оболочке ОС UNIX. Научиться писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.
### Ход Работы:
1. Напишем командный файл, реализующий упрощённый механизм семафоров. Командный файл должен в течение некоторого времени t1 дожидаться освобождения ресурса, выдавая об этом сообщение, а дождавшись его освобождения, использовать его в течение некоторого времени t2<>t1, также выдавая информацию о том, что ресурс используется соответствующим командным файлом (процессом).

Для выполнения данной задачи создадим файл semafor.sh и откроем его в emacs (рис.1).

![изображение](https://user-images.githubusercontent.com/104249657/170811928-ffdf7064-6de2-4cb2-9491-91981a0e0f04.png)

В файле напишем соответствующий скрипт (рис.2) и проверим его работу (команда ./semafor.sh 2 4), предварительно добавив права на выполнение (команда chmod +x semafor.sh) (рис.3).

![изображение](https://user-images.githubusercontent.com/104249657/170811951-dbc65cbe-a246-4a3f-8613-e3f74da709c8.png)

![изображение](https://user-images.githubusercontent.com/104249657/170811973-c5f06720-3928-4c5a-8ce2-7c1af9ba39ab.png)

Затем изменим скрипт так, чтобы можно было запускать командный файл в одном виртуальном терминале в фоновом режиме, перенаправив его вывод в другой (рис.4).

![изображение](https://user-images.githubusercontent.com/104249657/170811987-27c903f2-d089-42ac-948e-29c0dd357d27.png)

Проверим его работу (например, команда ./semafor.sh 2 4 Ожидание > /dev/pts/1) и увидим, что нам отказано в доступе (рис.6). Но при этом скрипт работает корректно (рис.7) при вводе команды ./semafor.sh 2 4 Ожидание.

![изображение](https://user-images.githubusercontent.com/104249657/170812007-4a9bb50a-396c-4910-9b86-a38fac4871d6.png)

![изображение](https://user-images.githubusercontent.com/104249657/170812024-2834155f-6a3a-4d52-a1a9-c5bd97820d49.png)

3. Используя встроенную переменную $RANDOM, напишим командный файл, генерирующий случайную последовательность букв латинского алфавита. Для этого создадим файл random.sh и откроем его в emacs.

Напишем скрипт для выполнения 3 задания (рис.14).

![изображение](https://user-images.githubusercontent.com/104249657/170812046-be1fc30c-7c5d-4ca4-9f35-70761159361a.png)

Проверим его работу (команда ./random.sh 158), предварительно дав ему право на выполнение с помощью команды chmod +x random.sh (рис.15).

![изображение](https://user-images.githubusercontent.com/104249657/170812064-455b1882-d30a-41a1-a058-505b92260a83.png)

# Выводы

Я изучил основы программирования в оболочке ОС UNIX и научился писать более сложные командные файлы с использованием логических управляющих конструкций и циклов.

# Контрольные вопросы 

1). while [$1 != "exit"]

В данной строчке допущены следующие ошибки:

 - не хватает пробелов после первой скобки [и перед второй скобкой ]

 - выражение $1 необходимо взять в “”, потому что эта переменная может содержать пробелы.

Таким образом, правильный вариант должен выглядеть так: while [“$1”!= "exit"]

2). Чтобы объединить несколько строк в одну, можно воспользоваться несколькими способами:

 - Первый:
VAR1="Hello,

"VAR2=" World"

VAR3="$VAR1$VAR2"

echo "$VAR3"

Результат: Hello, World

 - Второй:
VAR1="Hello, "

VAR1+=" World"

echo "$VAR1"

Результат: Hello, World

3). Команда seq в Linux используется для генерации чисел от ПЕРВОГО до ПОСЛЕДНЕГО шага INCREMENT.

Параметры:

 - seq LAST: если задан только один аргумент, он создает числа от 1 до LAST с шагом шага, равным 1. Если LAST меньше 1, значение is не выдает.

 - seq FIRST LAST: когда заданы два аргумента, он генерирует числа от FIRST до LAST с шагом 1, равным 1. Если LAST меньше FIRST, он не выдает никаких выходных данных.

 - seq FIRST INCREMENT LAST: когда заданы три аргумента, он генерирует числа от FIRST до LAST на шаге INCREMENT . Если LAST меньше, чем FIRST, он не производит вывод.

 - seq -f «FORMAT» FIRST INCREMENT LAST: эта команда используется для генерации последовательности в форматированном виде. FIRST и INCREMENT являются необязательными.

 - seq -s «STRING» ПЕРВЫЙ ВКЛЮЧЕНО: Эта команда используется для STRING для разделения чисел. По умолчанию это значение равно /n. FIRST и INCREMENT являются необязательными.

 - seq -w FIRST INCREMENT LAST:эта команда используется для выравнивания ширины путем заполнения начальными нулями. FIRST и INCREMENT являются необязательными.

4). Результатом данного выражения $((10/3))будет 3, потому что это целочисленное деление без остатка.

5). Отличия командной оболочки zshот bash:

 - В zsh более быстрое автодополнение для cdс помощью Тab

 - В zsh существует калькулятор zcalc, способный выполнять вычисления внутри терминала

 - В zsh поддерживаются числа с плавающей запятой

 - В zsh поддерживаются структуры данных «хэш»

 - В zsh поддерживается раскрытие полного пути на основе неполных данных

 - В zsh поддерживаетсязаменачастипути

 - В zsh есть возможность отображать разделенный экран, такой же как разделенный экран vim

6). for((a=1; a<= LIMIT; a++)) синтаксис данной конструкции верен, потому что, используя двойные круглые скобки, можно не писать $ перед переменными ().

7). Преимущества скриптового языка bash:

 - Один из самых распространенных и ставится по умолчаниюв большинстве дистрибутивах Linux, MacOS

 - Удобное перенаправление ввода/вывода

 - Большое количество команд для работы с файловыми системами Linux

 - Можно писать собственные скрипты, упрощающие работу в Linux

Недостатки скриптового языка bash:

 - Дополнительные библиотеки других языков позволяют выполнить больше действий

 - Bash не является языков общего назначения

 - Утилиты, при выполнении скрипта, запускают свои процессы, которые, в свою очередь, отражаются на быстроте выполнения этого скрипта

 - Скрипты, написанные на bash, нельзя запустить на других операционных системах без дополнительных действий.
